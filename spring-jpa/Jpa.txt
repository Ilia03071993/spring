    1. Для чего нужен Persistence context?
Persistence Context – набор экземпляров Entity, в котором для каждого уникального ID сущности существует уникальный экземпляр такой сущности. 
В контекст помещаются все сущности, с которыми производится работа в программе.
В Persistence Context осуществляется управление экземплярами сущностей и их жизненным циклом. 
Все операции, которые мы выполняем с Entity, сначала происходят с контекстом и лишь потом с БД.

2. Требуется каскадное обновление. Какой каскадный тип выбрать: Refresh или Merge?
Если нужно обновить все связанные сущности, включая их состояние, то лучше использовать каскадный тип Merge.

3. Какой каскадный тип нужно исключать из @ManyToMany и почему?
Исключить каскадный тип из @ManyToMany нужно Removе, из за удаления дочерней и родительской таблицы и их данных.

4. В чем отличие Transient и Detached?
Transient - это состояние нового объекта, который не находится в Persistence context(без ID),переходное состояние.
Detached - это состояние после фиксации транзакции (entityManager.getTransaction().commit()), сессия закрывается, Persistence context больше не управляет обьектами и изменения не отображаются в БД.

5. В чем проблема при ошибке: «removing a detached entity»?
Ошибка "removing a detached entity" возникает, когда пытаетесь удалить объект из базы данных, который был 
отсоединен от сеанса (detached). Это означает, что объект был загружен или создан в одном сеансе, а затем 
использован в другом сеансе или после закрытия сеанса.Для решения этой проблемы можно использовать метод merge()
для объединения состояния отсоединенного объекта с текущим сеансом, а затем выполнить удаление. Таким образом, 
объект будет снова привязан к сеансу и его удаление будет выполнено успешно

6. В чем проблема при ошибке: «object references an unsafe transient instance»?
Ошибка "object references an unsafe transient instance" возникает, когда пытаетесь сохранить или обновить объект, который ссылается на другой объект, не привязанный к сеансу (transient instance). Это может произойти, например, 
когда вы пытаетесь сохранить объект, который имеет ссылку на другой объект, созданный в предыдущем сеансе или загруженный из базы данных в другом контексте.
 Так же нужно учитывать при сохранении родительской сущности каскадно через дочернюю сущность,что сеттер родительской сущности в дочерней, проинициализирован корректно и сохраняется в объект. 
Пример у нас есть дочерний класс Manufaturer и родительский класс Product. В дочернем классе Manufaturer инициализирем метод setProduct:
   public void setProducts(List<Product> products) {
        for (Product product : products){
            product.setManufacturer(this);
        }
        this.products = products;
    }