1. Для чего нужны разные виды JOIN?
 Join - это соединение данных из таблиц между собой, бывают разные виды соединений: left, right,inner, full, cross - join. Соединение происходит по типу. 

Left join возвращает все строки из левой таблицы и соответствующие строки из правой таблицы, если таких нет в правой таблицы, то проставится null значение.

Right join aналогичен left join, только все строки проставятся из правой таблицы, а в левую таблицу подходящие по типу соединения.

Inner join - возвратит только те строки, которые имеют соответсвия в обеих таблицах.

Full join - возвращает все строки из обеих таблиц, строки объединяются, а если нет соответствия, то возвращается null.

2. Для чего нужны двунаправленные связи?
 Двунаправленнные связи необходимы при установки отношений между объектами или сущностями в обе стороны. В БД двунаправленнные связи используются для установления отношений между таблицами, когда необходимо иметь возможность получать информацию из обеих таблиц на основе связанных записей.

3.Когда и почему не рекомендуется использовать EAGER?
Fetch.type = EAGER не рекомендуется использовать c связью @ManyToMany
в таком случае будут подгружаться все дочерние сущности, даже если это не требуется, ухудшается производительность.
Безопасно использовать Eager для @OneToOne и @ManyToOne, так как будет подгрузка всего одной связанной сущности. Такой подход при необходимости может быть использован

4.Как написать собственный запрос с помощью Hibernate?
session.createMutationQuery("SQL code")
.setParameter("id", id)
.executeUpdate();

5. Для чего используется mappedBy?
Параметр mappedBy указывает на то, что ключ к отношениям находится на другой стороне, позволяет создавать Bi-directional связи. 

 6. Для чего используются каскадные типы?
Каскадные типы определяют операции, которые должны распространяться на дочерние сущности (связи). Каскадные типы: Persist, Merge, Remove, Detach, Refresh.

 7. Что нужно учитывать при сохранении родительской сущности каскадно через дочернюю сущность?
что сеттер родительской сущности в дочерней, проинициализирован корректно и сохраняется в объект. 
Пример у нас есть дочерний класс Manufaturer и родительский класс Product. В дочернем классе Manufaturer инициализирем метод setProduct:
   public void setProducts(List<Product> products) {
        for (Product product : products){
            product.setManufacturer(this);
        }
        this.products = products;
    }
